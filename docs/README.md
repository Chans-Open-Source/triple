# Triple Docs Chinese

### 1. Project structure

-triple/docs

Documentation

-triple/internal/

triple internal module

-codec/

    Unpack the module:

    codec.go: serialization component

    header.go: Triple protocol field definition component

    package.go: Data frame unpacking/packing module

-codes/

    grpc status code

-message/

    Internal data transmission structure/type definition

-status/

    grpc status

-stream/

    Two-way data flow structure definition

    processor.go: execute RPC process

    stream.go: Two-way data flow definition on the frame side

    user_stream.go: user-side two-way data stream definition

-syscall:

    Pressure test dependent module

-triple/pkg/

triple common module

-common/

    Public structure/interface/constant definition

-config/

    triple configuration

-triple/

    triple interface module

    dubbo3_client.go: triple network client

    dubbo3_conn.go: triple conn structure, used for grpc stub interface compatibility

    dubbo3_server.go: triple network server

    http2.go: Http2 request/service module

### 2. Interface description

-**Server interface**

**New Server**

  ```go
  // NewTripleServer can create Server with some user impl providers stored in @serviceMap
  // @serviceMap should be sync.Map: "interfaceKey" -> Dubbo3GrpcService
  func NewTripleServer(opt *config.Option, serviceMap *sync.Map, opt *config.Option)
  ```

Parameter function:

​ The key of serviceMap is the service id, which is dubbo interfaceKey. The value is the exposed grpc extended service, and the interface Dubbo3GrpcService needs to be implemented. After the stub is generated by the proto-gen tool, it can be realized by the user and put into the serviceMap. Multiple services can be placed in the serviceMap, and then a single app and multiple interfaces can be started.

​ opt is the service exposure configuration, you can pass in nil to start with the default configuration.

The server-side startup example can be seen in dubbo-go/protocol/dubbo3/dubbo3_protocol.go: Export()

**Open Server**

  ```go
  func (t *TripleServer) Start()
  ```

**Close Server**

  ```go
  func (t *TripleServer) Stop()
  ```



-**Client Interface**

**New Client**

  ```go
  // NewTripleClient create triple client
  // it's return tripleClient, contains invoker, and contain triple conn
  // @impl must have method: GetDubboStub(cc *dubbo3.TripleConn) interface{}, to be capable with grpc
  // @opt is used init http2 controller, if it's nil, use the default config
  func NewTripleClient(url *config.Option, impl interface{}, opt *config.Option) (*TripleClient, error) {
  ```

Parameter function:

​ opt is the service exposure configuration, you can pass in nil to start with the default configuration.

​ impl is the client structure that implements the GetDubboStub method. This method is implemented by the client user. It needs to return the XXXDubbo3Client structure that automatically generates the stub for the client to open and unpack the communication.

example:

  ```go
  type DubboGreeterImpl struct {
  Dubbo3SayHello2 func(ctx context.Context, in *dubbo32.Dubbo3HelloRequest, out *dubbo32.Dubbo3HelloReply) error
  BigUnaryTest func(ctx context.Context, in*dubbo32.BigData) (*dubbo32.BigData,error)
  }
  
  func (u *GrpcGreeterImpl) Reference() string {
  return "GrpcGreeterImpl"
  }
  
  // The GetDubboStub method returns the Dubbo Client generated in the stub
  func (u *DubboGreeterImpl) GetDubboStub(cc *dubbo3.TripleConn) dubbo32.Dubbo3GreeterClient {
  return dubbo32.NewDubbo3GreeterDubbo3Client(cc)
  }
  ```

**Normal RPC call**

```go
  // Request call h2Controller to send unary rpc req to server
  // @path is /interfaceKey/functionName e.g. /com.apache.dubbo.sample.basic.IGreeter/BigUnaryTest
  // @arg is request body
  func (t *TripleClient) Request(ctx context.Context, path string, arg, reply proto.Message) error
  ```

Parameter function:

​ ctx is the current request context, which may be associated with the triple protocol field

​ path is http2 path parameter: /interfaceKey/functionName structure, the server will locate the specific service corresponding function provided by the current app according to the path

​ reply is the return value.



**Streaming RPC call**

  ```go
  // StreamRequest call h2Controller to send streaming request to sever, to start link.
  // @path is /interfaceKey/functionName e.g. /com.apache.dubbo.sample.basic.IGreeter/BigStreamTest
  func (t *TripleClient) StreamRequest(ctx context.Context, path string) (grpc.ClientStream, error)
  ```

Parameter function:

​ ctx is the current request context, which may be associated with the triple protocol field

​ path is http2 path parameter: /interfaceKey/functionName structure, the server will locate the specific service corresponding function provided by the current app according to the path

The function returns the client stream structure of grpc, which is used to interact with the user

-GRPC stub interface

In the implementation of dubbo-go, the interface exposed by the above client needs to be registered on the grpc stub in the form of TripleConn. You can see that the TripleConn structure provides Invoke (normal call) and NewStream (streaming call) methods for incoming grpc stub.

  ```go
  Invoke(ctx context.Context, method string, args interface{}, reply interface{}, opts ...grpc.CallOption) error
  
  NewStream(ctx context.Context, method string, opts ...grpc.CallOption) (grpc.ClientStream, error)
  ```

